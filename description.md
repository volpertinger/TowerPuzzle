# Описание программы

## Краткое описание логики

### Класс \_\_Cell 

Этот класс используется для представления клетки в игровом поле и содержит функции для работы с клетками.
Содержит поле массива, в котором хранятся возможные числа для клетки.

#### Функция \_\_str\_\_ 

Реализована для строкового представления клетки. Клетка представляется ввиде [. . .], где вместо точек 
стоит N символов (N - размер игры) таких, что: символ = "-", если число в этой клетке стоять не может
и символ является числом, если это число может стоять в клетке. 

#### Функция \_\_int\_\_

Если в клетке стоит только одно число, то возвращаем его. Если несколько чисел может стоять в клетке, то
возвращаем 0.

#### Функция \_\_eq\_\_

Сравнивает клетки между собой и возвращает True, если клекти равны и False иначе.

#### Функция \_\_bool\_\_

Возвращает True, если в клетке стоит одно число и False иначе.

#### Функция set

Оставляет в клетке только заданное число, остальные убирает.

#### Функция remove

Убирает из клетки только заданное число.

#### Функция get_not_zeros

Возвращает все числа, которые могут стоять в клетке.

### Класс TowerPuzzle

Представляет собой поле и функции для работы с ним, решения головоломки. Сожержит следующие поля:

1. Четыре массива видимостей слева, сверху, справа, снизу.
2. Размер поля
3. Само поле, которое представляет собой двумерный массив клеток

#### Функция \_\_str\_\_

Нужна для наглядного представления поля со всеми видимостями и возможными значениями в клетках.

#### Функция get_field_from_arrray

Принимает на вход двумерный массив целых чисел и возвращает двумерный массив клеток 
(числу 0 во входном массиве соответствует клетка со всеми возможными числами, другим числам - клетка
с одним возможным заданным числом). Нужна для того, чтобы менее громоздко создавать поля.

#### Функция \_\_get_right_vector_from_possible

принимает на вход матрицу из векторов клеток (эти вектора являются всеми возможными комбинациями строки или транспонированного столбца, которые получаются из другой функции) и две крайние видимости.
Возвращает матрицу клеток, в котрой  каждая строка является верной по проверке видимостей и отсутствия дублей.

#### Функция \_\_get_cell_vector_from_matrix

принимает на вход матрицу из векторов клеток и возвращает один вектор, состоящий из клеток, который, по сути, является обобщением матрицы. Т.е. эта функции их возможных комбинаций вектора делает вектор
клеток, в которых, в зависимости от исходной матрицы, на определенных позициях в клетках возможны определенные значения.

#### Функция get_field_string

Эта функция нужная для упрощенного представления поля головоломки ввиде строки. На выходе получается строчное представление матрицы, где последовательно выписаны ее элементы, причем если число в клетке определено однозначно, то оно и ставится, а если есть несколько вариантов для клетки, то ставится на соответственную позицию 0.

#### Функции \_\_count_visibility_[left/right/up/down]

Принимает на вход индекс и считает текущую видимость в нужной строке\столбце в направлении, зависящем от функции.

#### Функция \_\_count_unfilled_cells_[horizontal/vertical]

Принимает на вход индекс и считает количество клеток в нужной строке\столбце, в которых однозначно не определено число.

#### Функция \_\_count_brute_force_variants

Возвращает число вариантов для перебора для текущего состояния поля для первой клетки (обход матрицы слева направо и сверху вниз), значение для которой не определено.

#### Функция \_\_is_unique_[row/column]

Получает на вход строку\стлбец и возвращает True, если в векторе нет повторяющихся клеток с точно определенными значениями.

#### Функция \_\_is_solved

Проверяет, решена ли игра по текущему полю. Возвращает True, если игра решена и False иначе

#### Функция \_\_is_correct

Проверяет текущее поле на корректность (здесь, в отличие от предыдущей функции, учитывается, что клетки могут быть не заполнены)

#### Функция \_\_set

Принимает на вход индексы и число, которое нужно поставить в клетку по нужным индексам. Если значение в клетке уже определено, то ничего функция не делает. Иначе - ставит число.

#### Функция \_\_remove

Принимает на вход индексы и число, которое нужно удалить из клетки. Если значение в клетке определено, то возвращает False. Иначе - удаляет число по индексам.

#### Функция \_\_remove_higher

Принимает на вход индексы и число. И вызывает функцию \_\_remove для всех чисел, больших заданного.

#### Функция \_\_solve_trivial_highest

Рещает примитивный случай, когда видимость = 1

#### Функция \_\_solve_base_restrictions

Распространяет базовые ограничения из условий видимости.

#### Функция \_\_solve_castle_restrictions

Получает на вход индексы. Если по этому индексу число в клетке не определено однозначно, то ничего функция не делает. Иначе в строке и столбце, исходя из индексов, за исключнием этой клетки, вызывает \_\_remove по индексу и числу, которое однозначно определено в исходной клетке.

#### Функция \_\_solve_only_one_[row\column]

Если в заданной строке\столбце исходя из ограничений только в одной клетке возможно определенное число, то оно и выставляется.

#### Функция \_\_get_possible_[rows\columns]

Получает на вход индекс строки\столбца и для строит матрицу возможных векторов исходя из ограничений.

#### Функция \_\_solve_visibility_restriction_[row\column]

Получает на вход индекс строки\столбца и для него составляет возможные комбинации векторов исходя из ограничений, затем отбирает верные исходя из видимостей и составляет вектор клеток (с помощью вызова уже описанных ранее функций). Затем, если так оказалось, что вектор клеток пустой (нет возможных правильных комбинаций), то возвращается False. Затем проверяется, равняется полученний вктор исходному в поле. Если равняется, то вовзращается False. Иначе - True.

#### Функция \_\_solve_number_brute_force

получает на вход позицию, с которой начинать перебор. Затем идет по полю и, когда достигает нужной позиции, ставит число в клетку. Если позиции достигнуть не удается (т.е. уже все возможное перебрали), то возвращается False. Иначе - True.

#### Функция \_\_solve_trivial_cases

Вызывает функции для решения тривиальных случаев для стартовой позиции.

#### Функция \_\_solve_by_restrictions

Решает задачу алгоритмом распространения ограничений, без перебора. Если никаким из непереборных способов решить не удается, возвращает True, если задача решена и False иначе.

#### Функция \_\_solve 

Полностью решает задачу с учтом перебора, если это нужно. Сначала решает распространением ограничений, затем, если эти методом решить нельзя и задача еще не решена, вставляет значение для одной клетки перебором, а затем снова алгоритмом рспространения ограничений. При этом сохраняются точки, в которых начался перебор (поле и позиция), чтобы если перебор ведет в тупик, вернуться назад. В случае, если нельзя решить распространением ограничений и закончились варианты для перебора, возвращается False. Если игра решена, то возвращается True.

## Использованные структуры данных

### Класс \_\_Cell

Для хранения возможных значений использован массив т.к. размер определяется один раз, а затем по индексам происходит изменение значения. Поэтому эта структура данных оптимальна.

### Класс \_\_TowerPuzzle

Для хранения видимостей использованы массивы т.к. размер определяется один раз, а затем просто получаем значение по индексам, поэтому массив оптимален.

Для хранения поля использован двумерный массив т.к. его размер определяется один раз, а затем просто идет изменение значений по индексам и получение значений. Поэтому такая структура данных оптимальна.

## Оценка вычислительной сложности

Ниже в оценках N - размер игры.

### Класс \_\_Cell 

#### Функция \_\_str\_\_ 

Проходим по каждому элементу массива и записывает значение в результат. Сложность O(N).

#### Функция \_\_int\_\_

Считает количесвто "0" в массиве (что соответствует тому, что число на данной позиции точно не стоит в клетке) за O(N), затем проверка на количество нулей и возврат значения. Сложность O(N).

#### Функция \_\_eq\_\_

Сравнивает два массива. Сложность O(N).

#### Функция \_\_bool\_\_

Считает количество "0" и в зависимости от этого количества и размера возвращает значение. Сложность O(N).

#### Функция set

Создается новый массив и по индексу выставляется нужное значение. Сложность O(1).

#### Функция remove

Считается количество "0" в массиве. и в зависимости от этого значение по индексу изменяется на "0" или нет. Сложность O(N).

#### Функция get_not_zeros

Проходим по массиву и заполняем массив - результат, если элемент не равен "0". Сложность O(N).

### Класс TowerPuzzle

#### Функция \_\_str\_\_

Заполняется в результат каждая клетка массива и видимости. Сложность O(N^2).

#### Функция get_field_from_arrray

Для каждого элемента двумерного массива на входе создается значение в двумерном массиве результата. Сложность O(N^2).

#### Функция \_\_get_right_vector_from_possible

Для каждого векора из матрицы: проверяются видимости за O(N) и количесвто уникальных элементов за O(N) для каждого элемента из N. Всего векторов в худшем N^N. Тогда сложность (N^N).

#### Функция \_\_get_cell_vector_from_matrix

Для каждого столбца из матрицы векторов составляется клетка для вектора - результата за O(N^N) в худшем. Всего таких столбцов - по размеру  игры - N. Тогда сложность O(N^N).

#### Функция get_field_string

Проходит по всей матрице поля и записывает результат в строку. Сложность O(N^2).

#### Функции \_\_count_visibility_[left/right/up/down]

Проходит один раз по всему вектору, считая видимость. Сложность O(N).

#### Функция \_\_count_unfilled_cells_[horizontal/vertical]

Проходит по всему вектору, считая клетки, в которых значение однозначно не определено. Сложность O(N).

#### Функция \_\_count_brute_force_variants

Проходит по всей матрице, пока не найдет клетку, в которой значение однозначно не определено и возвращает количество вариантов чисел для нее. Сложность O(N^2).

#### Функция \_\_is_unique_[row/column]

Проверяет, нет ли в векторе повторяющихся чисел в клетках, значение которых однозначно определено. Сложность O(N^2).

#### Функция \_\_is_solved

Проверяет для каждой строки и столбца видимости за O(N) и заполненность каждой клетки за O(N). Тогда сложность O(N^3).

#### Функция \_\_is_correct

Проверяет уникальность каждой строки и столбца за O(N^2), а также видимости за O(N) и считает незаполненные клетки за O(N). Сложность O(N^3).

#### Функция \_\_set

Ставит значение в клетке по индексу за O(1).

#### Функция \_\_remove

Удаляет значение из клетки по индексу за O(1).

#### Функция \_\_remove_higher

Удаляет все значения, большие числа на входе за O(N).

#### Функция \_\_solve_trivial_highest

Прохлдит по всем клеткам видимости и может ставить значение в клетке поля по индексу. Сложность O(N).

#### Функция \_\_solve_base_restrictions

Считает для каждой клетки ограничения по видимости и удаляет соответствующие значения. Сложность O(N^3).

#### Функция \_\_solve_castle_restrictions

Для клетки удаляет значение в столбце и строке. Сложность O(N).

#### Функция \_\_solve_only_one_[row\column]

Проверяет строку или столбец на наличие только одного возможного значения в ограничениях и может поставить значение в клетку. Сложность O(N).

#### Функция \_\_get_possible_[rows\columns]

Получает из вектора, исходя из ограничений, матрицу возможных векторов. В худшем вслучае слодность O(N^N).

#### Функция \_\_solve_visibility_restriction_[row\column]

Для вектора получает возмодные вектора, затем отбирает правильные и делает из них вектор клеток, затем этот вектор клеток сравнивается с изначальным. Сложность O(N^N) в худшем.

#### Функция \_\_solve_number_brute_force

Проходит по матрице поля и ставит в клетку по нужной позиции перебора число. Сложность O(N^2).

#### Функция \_\_solve_trivial_cases

Вызывает функции, сложности которых O(N) и O(N^3). Сложность O(N^3).

#### Функция \_\_solve_by_restrictions

Вызывает в цикле функции, сложности которых O(N) для каждой клетки, O(N) для каждой строки и столбца, O(N^N) для каждой строки и столбца, пока хотя бы одним из этих способов удается продвинуть решение. Сложность в худшем O(N^N).

#### Функция \_\_solve 

Эта фуекция использует предыдущую, но если не удается предыдущей продвинуть решение, то начинает перебор, сложность которого O(N^(N^N)). Тогда сложность в худшем O(N^(N^N)).

## Оценка сложности по памяти

### Класс \_\_Cell 

Хранит массив размера O(N).

#### Функция \_\_str\_\_ 

Хранит массив результата сложностью O(N).

#### Функция \_\_int\_\_

Просто проходит по массиву, ничего лишнего не хранит. Сложность O(1).

#### Функция \_\_eq\_\_

Проходит по двум массивам, сравнивая их, ничего лишнего не хранит. Сложность O(1).

#### Функция \_\_bool\_\_

Считает количество "0" в массиве, ничего лишнего не хранит. Сложность O(1).

#### Функция set

Изменяет значение по индексу, ничего лишнего не хранит. Сложность O(1).

#### Функция remove

Изменяет значение по индексу, ничего лишнего не хранит. Сложность O(1).

#### Функция get_not_zeros

Проходит по массиву и заполняет массив результата. В худшем хранит N элементов. Сложность O(N).

### Класс TowerPuzzle

Хранит 4 массива с видимостями за O(N), двумерный массив с полем из N^2 элеметов, каждый из которых хранит массив размера O(N), тогда массив поля хранится за O(N^3). Еще хранится размер игры за O(1). Тогда сложность O(N^3).

#### Функция \_\_str\_\_

Хранит строку результата из N^3 элементов матрицы поля и еще фиксированным количеством вспомагаьельных символов. Тогда сложность O(N^3).

#### Функция get_field_from_arrray

Хранит результат поля, которое харнит N^2 элементов, каждый из которых хранит массив из N элементов. Тогда сложность O(N^3).

#### Функция \_\_get_right_vector_from_possible

В худшем случае может быть N! правильных векторов, которые записываются в результат. Причем каждый вектор состоит из N элементов. Тогда сложность O(N\*N!).

#### Функция \_\_get_cell_vector_from_matrix

Хрнаит уникаьлные столбцы, в худшем за O(N), уникальные вектора, в худшем O(N\*N!), а также результат - вектор размера N, элементы которого хранят массив из N элементов, т.е. N^2 элементов в результате. Тогда сложность O(N\*N!). 

#### Функция get_field_string

Хранит в результате только по одному числу для каждого элемента матрицы поля. Сложность O(N^2).

#### Функции \_\_count_visibility_[left/right/up/down]

Хранит только результат и максимальную высоту. Сложность O(1).

#### Функция \_\_count_unfilled_cells_[horizontal/vertical]

Хранит только значение результата. Сложность O(1).

#### Функция \_\_count_brute_force_variants

Хранит только целочисленный результат. Сложность O(1).

#### Функция \_\_is_unique_[row/column]

Хранит в худшем случае массив из N элементов. Сложность O(1).

#### Функция \_\_is_solved

Ничего лишнего не хранит, сложность O(1).

#### Функция \_\_is_correct

Ничего лишнего не хранит, сложность O(1).

#### Функция \_\_set

Ничего лишнего не хранит, сложность O(1).

#### Функция \_\_remove

Ничего лишнего не хранит, сложность O(1).

#### Функция \_\_remove_higher

Ничего лишнего не хранит, сложность O(1).

#### Функция \_\_solve_trivial_highest

Ничего лишнего не хранит, сложность O(1).

#### Функция \_\_solve_base_restrictions

Ничего лишнего не хранит, сложность O(1).

#### Функция \_\_solve_castle_restrictions

Хранит булевый результат и число. Сложность O(1).

#### Функция \_\_solve_only_one_[row\column]

Хранит ассоциативный массив количества чисел, в худшем из N пар ключ-значение, которые являются целыми числами, а также текущее уелочисленное число. Тогда сложность O(N).

#### Функция \_\_get_possible_[rows\columns]

В худшем случае хранит матрицу из N^N элементов, каждый из которых - массив из N элементов. Тогда сложность O(N^N).

#### Функция \_\_solve_visibility_restriction_[row\column]

Хранить в результате в самом начале может в худшем все возможные вектора, а это O(N^N).

#### Функция \_\_solve_number_brute_force

Хранит целочисленное значение текущий позиции для перебора и нужную позицию. Сложность O(N).

#### Функция \_\_solve_trivial_cases

Вызывает функции, сложность которых O(1). Тогда сложность O(1).

#### Функция \_\_solve_by_restrictions

Хранит булевый результат и вызывает функции, сложность которых O(1), O(N), O(N^N). Тогда сложность O(N^N).

#### Функция \_\_solve 

Вызывает прошлую функцию, сложность которой O(N^N). Дополнительно для перебора хранит два массива с значениями для возврата, если перебор ведет в тупик. Всего в худшем вариантов для перебора O(N^(N^N)), тогда в худшем массив позици для перебора хранит N^(N^N) целочисленных значений и N^(N^N) значений поля, которое хранит N^2 элементов, каждый их которых хранит массив из N элементов. Тогда сложность O(N^(N^N)).
